import jsonschema2md
import os
import logging
import yaml
import configparser
from ruamel.yaml import YAML, YAMLError

NESTED_REFERENCE_LIMIT = 3

DEFINITION_PREFIX = "def_"

CROSS_REF_TERM = "Refer to *#/definitions/"

logging.basicConfig(level=logging.INFO)

DOSDP_SCHEMA = os.path.join(os.path.dirname(os.path.realpath(__file__)), "../schema/dosdp_schema2.yaml")
DOSDP_SCHEMA_MD = os.path.join(os.path.dirname(os.path.realpath(__file__)), "../schema/dosdp_schema.md")
DOSDP_DOCUMENTATION_CONF = os.path.join(os.path.dirname(os.path.realpath(__file__)), "../schema/dosdp_schema_doc.ini")


def generate_plain_documentation(yaml_schema):
    """
    Generates a plain documentation using jsonschema2md library.

    Returns: Dictionary of element documentations. Key is element name and value is list of documentation lines.
    """
    parser = jsonschema2md.Parser()

    with open(yaml_schema, 'r') as yaml_in:
        dosdp = yaml.safe_load(yaml_in)
        md_lines = parser.parse_schema(dosdp)

        plain_documentation = dict()
        element_lines = []
        element_name = ""

        is_definition = False
        for line in md_lines:
            if line.startswith("## Definitions"):
                is_definition = True
            elif line.startswith("## Properties"):
                is_definition = False

            line = line.replace("\n", "")

            if line.startswith("- **`"):
                if element_name:
                    plain_documentation[element_name] = element_lines
                element_lines = [line]
                element_name = get_element_name(is_definition, line)
            elif line and not line.startswith("## "):
                element_lines.append(line)

        plain_documentation[element_name] = element_lines
        handle_one_of_definitions(plain_documentation)

        return plain_documentation


def get_element_name(is_definition, line):
    """
    Extract element name from jsonschema2md generated documentation line.
    """
    first_occur = line.index("**")
    second_occur = line.index("**", first_occur + 1)
    element_name = line[first_occur + 3:second_occur - 1]
    if is_definition:
        element_name = DEFINITION_PREFIX + element_name
    return element_name


def handle_one_of_definitions(plain_documentation):
    """
    'OneOf' definitions are not handled by the jsonschema2md. Manually adding documentation for these definitions.
    """
    ryaml = YAML(typ='safe')
    with open(DOSDP_SCHEMA, "r") as stream:
        try:
            content = ryaml.load(stream)
            definitions = content["definitions"]
            for key in definitions.keys():
                if "oneOf" in definitions[key]:
                    element_lines = ["One of:"]
                    one_of_defs = definitions[key]["oneOf"]
                    for one_of_item in one_of_defs:
                        element_lines.append("  - **Items**: Refer to *"+one_of_item["$ref"]+"*.")
                    plain_documentation[DEFINITION_PREFIX + key] = element_lines
        except YAMLError as exc:
            logging.error('Failed to load pattern file: ' + DOSDP_SCHEMA)


def print_documentation_header(doc_type_elements, md_out):
    """
    Add headings to the documentation
    """
    md_out.write("# %s\n" % doc_type_elements["doc_title"])
    md_out.write("\n")
    md_out.write("## %s\n" % "Properties")
    md_out.write("\n")


def print_element(element, md_out, plain_doc, prefix=""):
    """
    Retrieves plain element documentation generated by the jsonschema2md and writes to the document.
    Additionally expands 'definitions' references to a specified depth (see NESTED_REFERENCE_LIMIT)
    in order to prevent indefinite circular references.
    """
    lines = plain_doc[element]
    for line in lines:
        md_out.write("%s\n" % (prefix + line))
        if CROSS_REF_TERM in line and len(prefix) < NESTED_REFERENCE_LIMIT:
            ref_term_start = line.index(CROSS_REF_TERM) + len(CROSS_REF_TERM)
            referred_element = line[ref_term_start:len(line) - 2]
            print_element(DEFINITION_PREFIX + referred_element, md_out, plain_doc, ">"+prefix)


def print_section_header(config, md_out, section):
    """
    Adds a section title and description for doc_type.
    'root' doc_type is a special type and doesn't have a title and description.
    """
    if not section == "root":
        section_config = config[section]
        md_out.write("### %s\n" % section_config["title"])
        md_out.write("\n")
        md_out.write("%s\n" % section_config["description"])
        md_out.write("\n")


def get_doc_type_elements():
    """
    Reads the schema file and builds a list of doc_type elements.

    Returns: dictionary of schema elements. Key is doc_type (as defined in the ini config)
    and value is list of element names.
    """
    doc_type_elements = dict()

    ryaml = YAML(typ='safe')
    with open(DOSDP_SCHEMA, "r") as stream:
        try:
            content = ryaml.load(stream)
            doc_type_elements["doc_title"] = content["title"]
            properties = content["properties"]

            for key in properties.keys():
                doc_type = properties[key]["doc_type"]
                if doc_type in doc_type_elements:
                    doc_type_elements[doc_type].append(key)
                else:
                    doc_type_elements[doc_type] = [key]
        except YAMLError as exc:
            logging.error('Failed to load pattern file: ' + DOSDP_SCHEMA)
    return doc_type_elements


def generate_documentation(yaml_schema):
    """
    Generates documentation for the given YAML schema. Uses jsonschema2md to generate a plain documentation,
    then decorates generated documentation through using the documentation config (.ini file)
    """
    plain_doc = generate_plain_documentation(yaml_schema)

    config = configparser.ConfigParser()
    config.read(DOSDP_DOCUMENTATION_CONF)
    sections = config.sections()

    doc_type_elements = get_doc_type_elements()

    with open(DOSDP_SCHEMA_MD, "w") as md_out:
        print_documentation_header(doc_type_elements, md_out)

        for section in sections:
            elements = doc_type_elements[section]
            print_section_header(config, md_out, section)

            for element in elements:
                print_element(element, md_out, plain_doc)
                md_out.write("\n\n")


generate_documentation(DOSDP_SCHEMA)


